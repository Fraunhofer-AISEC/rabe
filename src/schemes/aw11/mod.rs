//! `AW11` scheme by Lewko, Allison, and Brent Waters.
//!
//! * Developped by Lewko, Allison, and Brent Waters, "Decentralizing Attribute-Based Encryption.", see Appendix D
//! * Published in Eurocrypt 2011
//! * Available from <http://eprint.iacr.org/2010/351.pdf>
//! * Type:			encryption (identity-based)
//! * Setting:		bilinear groups (asymmetric)
//! * Authors:		Georg Bramm
//! * Date:			04/2018
//!
//! # Examples
//!
//! ```
//!use rabe::schemes::aw11::*;
//! use rabe::utils::policy::pest::PolicyLanguage;
//!let gk = setup();
//!let (pk, msk) = authgen(&gk, &vec!["A", "B"]).unwrap();
//!let plaintext = String::from("our plaintext!").into_bytes();
//!let policy = String::from(r#""A" or "B""#);
//!let bob = keygen(&gk, &msk, &String::from("bob"), &vec!["A"]).unwrap();
//!let ct: Aw11Ciphertext = encrypt(&gk, &[&pk], &policy, PolicyLanguage::HumanPolicy, &plaintext).unwrap();
//!let matching = decrypt(&gk, &bob, &ct).unwrap();
//!assert_eq!(matching, plaintext);
//! ```
use std::string::String;
use rand::Rng;
use rabe_bn::{Fr, G1, G2, Gt, pairing};
use utils::{
    secretsharing::{
        calc_coefficients,
        calc_pruned
    },
    policy::msp::AbePolicy,
    tools::*,
    aes::*,
    hash::sha3_hash
};
use utils::policy::pest::{PolicyLanguage, parse, PolicyType};
use utils::secretsharing::{gen_shares_policy, remove_index};
use crate::error::RabeError;
#[cfg(feature = "serde")]
use serde::{Serialize, Deserialize};
#[cfg(feature = "borsh")]
use borsh::{BorshSerialize, BorshDeserialize};

/// An AW11 Global Parameters Key (GK)
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "borsh", derive(BorshSerialize, BorshDeserialize))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct Aw11GlobalKey {
    pub g1: G1,
    pub g2: G2,
}

/// An AW11 Public Key (PK)
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "borsh", derive(BorshSerialize, BorshDeserialize))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct Aw11PublicKey {
    pub attr: Vec<(String, Gt, G2)>,
}

/// An AW11 Master Key (MK)
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "borsh", derive(BorshSerialize, BorshDeserialize))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct Aw11MasterKey {
    pub attr: Vec<(String, Fr, Fr)>,
}

/// An AW11 Ciphertext (CT)
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "borsh", derive(BorshSerialize, BorshDeserialize))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct Aw11Ciphertext {
    pub policy: (String, PolicyLanguage),
    pub c_0: Gt,
    pub c: Vec<(String, Gt, G2, G2)>,
    pub ct: Vec<u8>,
}

/// An AW11 Secret Key (SK)
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "borsh", derive(BorshSerialize, BorshDeserialize))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct Aw11SecretKey {
    pub gid: String,
    pub attr: Vec<(String, G1)>,
}

/// A global Context for an AW11 Global Parameters Key (GP)
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "borsh", derive(BorshSerialize, BorshDeserialize))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct Aw11GlobalContext {
    pub key: Aw11GlobalKey,
}

/// Sets up a new AW11 Scheme by creating a Global Parameters Key (GK)
pub fn setup() -> Aw11GlobalKey {
    // random number generator
    let mut rng = rand::thread_rng();
    // generator of group G1: g1 and generator of group G2: g2
    Aw11GlobalKey {
        g1: rng.gen(),
        g2: rng.gen(),
    }
}

/// Sets up a new AW11 Authority by creating a key pair: Public Parameters Key (PK) and Master Key (MK)
///
/// # Arguments
///
///	* `gk` - A Global Parameters Key (GK), generated by the function setup()
///	* `attributes` - A Vector of String attributes assigned to this Authority
///
/// # Remarks
///
/// In this scheme, all attributes are converted to upper case bevor calculation, i.e. they are case insensitive
/// This means that all attributes "tEsT", "TEST" and "test" are the same in this scheme.
pub fn authgen(
    gk: &Aw11GlobalKey,
    attributes: &[&str],
) -> Option<(Aw11PublicKey, Aw11MasterKey)> {
    // if no attibutes or an empty policy
    // maybe add empty msk also here
    if attributes.is_empty() {
        return None;
    }
    // random number generator
    let mut rng = rand::thread_rng();
    // generator of group G1: g and generator of group G2: h
    let mut sk: Vec<(String, Fr, Fr)> = Vec::new(); //dictionary of {s: {alpha_i, y_i}}
    let mut pk: Vec<(String, Gt, G2)> = Vec::new(); // dictionary of {s: {e(g,g)^alpha_i, g1^y_i}}
    // now calculate attribute values
    for attr in attributes {
        let name = attr.to_string().to_uppercase();
        // calculate randomness
        let alpha_i:Fr = rng.gen();
        let y_i:Fr = rng.gen();
        sk.push((name.clone(), alpha_i, y_i));
        pk.push((
            name,
            pairing(gk.g1, gk.g2).pow(alpha_i),
            gk.g2 * y_i,
        ));
    }
    // return PK and MSK
    return Some((Aw11PublicKey { attr: pk }, Aw11MasterKey { attr: sk }));
}

/// Sets up and generates a new User by creating a secret user key (SK). The key is created for a user with a given "name" on the given set of attributes.
///
/// # Arguments
///
///	* `gk` - A Global Parameters Key (GK), generated by setup()
///	* `msk` - A Master Key (MK), associated with an authority and generated by authgen()
///	* `name` - The name of the user the key is associated with. Must be unique.
///	* `attributes` - A Vector of String attributes assigned to this User
///
/// # Remarks
///
/// In this scheme, all attributes are converted to upper case bevor calculation, i.e. they are case insensitive
/// This means that all attributes "tEsT", "TEST" and "test" are treated the same in this scheme.
pub fn keygen(
    gk: &Aw11GlobalKey,
    msk: &Aw11MasterKey,
    name: &str,
    attributes: &[&str],
) -> Result<Aw11SecretKey, RabeError> {
    // if no attibutes or no gid
    if attributes.is_empty() {
        Err(RabeError::new("empty _attributes"))
    }
    else if name.is_empty() {
        Err(RabeError::new("empty _name"))
    }
    else {
        let mut _sk: Aw11SecretKey = Aw11SecretKey {
            gid: name.to_string(),
            attr: Vec::new(),
        };
        for _attribute in attributes {
            if let Err(e) =  add_to_attribute(gk, msk, _attribute, &mut _sk) {
                return Err(e);
            }
        }
        Ok(_sk)
    }
}

/// This function does not create a new User key, but adds a new attribute to an already generated key (SK).
///
/// # Arguments
///
///	* `gk` - A Global Parameters Key (GK), generated by setup()
///	* `msk` - A Master Key (MK), associated with an authority and generated by authgen()
///	* `attribute` - A String attribute that should be added to the already existing key (SK)
///	* `sk` - The secret user key (SK)
pub fn add_to_attribute(
    gk: &Aw11GlobalKey,
    msk: &Aw11MasterKey,
    attribute: &str,
    sk: &mut Aw11SecretKey,
) -> Result<(), RabeError> {
    // if no attibutes or no gid
    if attribute.is_empty() {
        Err(RabeError::new("empty _attributes"))
    }
    else if sk.gid.is_empty() {
        Err(RabeError::new("empty _gid"))
    }
    else {
        match sha3_hash(gk.g1, &sk.gid) {
            Ok(hash) => {
                let auth_attribute = msk
                    .attr
                    .iter()
                    .filter(|_attr| _attr.0 == attribute.to_string())
                    .nth(0)
                    .unwrap();
                sk.attr.push((
                    auth_attribute.0.clone().to_uppercase(),
                    (gk.g1 * auth_attribute.1) + (hash * auth_attribute.2),
                ));
                Ok(())
            },
            Err(e) => Err(e)
        }
    }
}

/// This function encrypts plaintext data using a given JSON String policy and produces a 'Aw11Ciphertext' if successfull.
///
/// # Arguments
///
///	* `gk` - A Global Parameters Key (GK), generated by setup()
///	* `pk` - A Public Parameters Key (MK), associated with an authority and generated by authgen()
///	* `policy` - A JSON String policy describing the access rights
///	* `plaintext` - The plaintext data given as a Vector of u8.
pub fn encrypt(
    gk: &Aw11GlobalKey,
    pks: &[&Aw11PublicKey],
    policy: &str,
    language: PolicyLanguage,
    data: &[u8],
) -> Result<Aw11Ciphertext, RabeError> {
    // random number generator
    let mut _rng = rand::thread_rng();
    match parse(policy, language) {
        Ok(pol) => {
            // an msp policy from the given String
            let msp: AbePolicy = AbePolicy::from_policy(&pol).unwrap();
            let _num_cols = msp.m[0].len();
            let _num_rows = msp.m.len();
            // pick randomness
            let _s:Fr = _rng.gen();
            // and calculate shares "s" and "zero"
            let _s_shares = gen_shares_policy(_s, &pol, None).unwrap();
            let _w_shares = gen_shares_policy(Fr::zero(), &pol, None).unwrap();
            // calculate c0 with a randomly selected "msg"
            let _msg: Gt = _rng.gen();
            let c_0 = _msg * pairing(gk.g1, gk.g2).pow(_s);
            // now calculate the C1,x C2,x and C3,x parts
            let mut c: Vec<(String, Gt, G2, G2)> = Vec::new();
            for (_i, (_attr_name, _attr_share)) in _s_shares.into_iter().enumerate() {
                let _r_x:Fr = _rng.gen();
                let _pk_attr = find_pk_attr(pks, &remove_index(&_attr_name.to_uppercase()));
                match _pk_attr {
                    None => {},
                    Some(_attr) => {
                        c.push((
                            _attr_name.clone().to_uppercase(),
                            pairing(gk.g1, gk.g2).pow(_attr_share) * _attr.1.pow(_r_x),
                            gk.g2 * _r_x,
                            (_attr.2 * _r_x) + (gk.g2 * _w_shares[_i].1),
                        ));
                    }
                }
            }
            //Encrypt plaintext using derived key from secret
            match encrypt_symmetric(_msg, &data.to_vec()) {
                Ok(ct) => Ok(Aw11Ciphertext { policy: (policy.to_string(), language), c_0, c, ct }),
                Err(e) => Err(e)
            }
        },
        Err(e) => Err(e)
    }
}

/// This function decrypts a 'Aw11Ciphertext' if the attributes in SK match the policy of CT. If successfull, returns the plaintext data as a Vetor of u8's.
///
/// # Arguments
///
///	* `gk` - A Global Parameters Key (GK), generated by setup()
///	* `sk` - A secret user key (SK), associated with a set of attributes.
///	* `ct` - A Aw11Ciphertext
pub fn decrypt(
    gk: &Aw11GlobalKey,
    sk: &Aw11SecretKey,
    ct: &Aw11Ciphertext
) -> Result<Vec<u8>, RabeError> {
    let str_attr = sk
        .attr
        .iter()
        .map(|_values| {
            let (_str, _g2) = _values.clone();
            _str
        })
        .collect::<Vec<_>>();
    return match parse(ct.policy.0.as_ref(), ct.policy.1) {
        Ok(pol) => {
            return if traverse_policy(&str_attr, &pol, PolicyType::Leaf) == false {
                Err(RabeError::new("Error: attributes in sk do not match policy in ct."))
            } else {
                let _pruned = calc_pruned(&str_attr, &pol, None);
                match _pruned {
                    Err(e) => Err(e),
                    Ok(_p) => {
                        let (_match, _list) = _p;
                        let mut coeff_list: Vec<(String, Fr)> = Vec::new();
                        coeff_list = calc_coefficients(&pol, Some(Fr::one()), coeff_list,None).unwrap();
                        if _match {
                            match sha3_hash(gk.g1, &sk.gid) {
                                Ok(hash) => {
                                    let mut _egg_s = Gt::one();
                                    for _current in _list.iter() {
                                        let _sk_attr = sk
                                            .attr
                                            .iter()
                                            .filter(|_attr| _attr.0 == _current.0.to_string())
                                            .nth(0)
                                            .unwrap();
                                        let _ct_attr = ct
                                            .c
                                            .iter()
                                            .filter(|_attr| _attr.0 == _current.1.to_string())
                                            .nth(0)
                                            .unwrap();
                                        let num = _ct_attr.1 * pairing(hash, _ct_attr.3);
                                        let dem = pairing(_sk_attr.1, _ct_attr.2);
                                        let _coeff = coeff_list
                                            .iter()
                                            .filter(|_c| _c.0 == _current.1.to_string())
                                            .map(|_c| _c.1)
                                            .nth(0)
                                            .unwrap();
                                        _egg_s = _egg_s * ((num * dem.inverse()).pow(_coeff));
                                    }
                                    let _msg = ct.c_0 * _egg_s.inverse();
                                    //println!("dec: {:?}", serde_json::to_string(&_msg).unwrap());
                                    // Decrypt plaintext using derived secret from cp-abe scheme
                                    decrypt_symmetric(_msg, &ct.ct)
                                },
                                Err(e) => Err(e)
                            }
                        } else {
                            Err(RabeError::new("Error in aw11/decrypt: attributes in sk do not match policy in ct."))
                        }
                    }
                }
            }
        },
        Err(e) => Err(e)
    }
}
/// private function. finds the value vector of a specific attribute in a vector of various public keys
///
/// # Arguments
///
///	* `pks` - A vector of Aw11PublicKeys
///	* `attr` - An attribute
///
fn find_pk_attr(
    pks: &[&Aw11PublicKey],
    attr: &str
) -> Option<(String, Gt, G2)> {
    for _pk in pks.into_iter() {
        let _pk_attr = _pk
            .attr
            .clone()
            .into_iter()
            .filter(|_tuple| _tuple.0 == attr.to_string())
            .nth(0);
        if _pk_attr.is_some() {
            return _pk_attr;
        }
    }
    return None;
}

#[cfg(test)]
mod tests {

    use super::*;

    #[test]
    fn and() {
        // global setup
        let _gp = setup();
        // setup attribute authority 1 with
        // a set of two attributes "A" "B" "C"
        let att_authority1: Vec<&str> = vec!["A","B","C"];
        let (_auth1_pk, _auth1_msk) = authgen(&_gp, &att_authority1).unwrap();
        // setup attribute authority 1 with
        // a set of two attributes "D" "E" "F"
        let att_authority2: Vec<&str> = vec!["D","E","F"];
        let (_auth2_pk, _auth2_msk) = authgen(&_gp, &att_authority2).unwrap();
        // setup attribute authority 1 with
        // a set of two attributes "G" "H" "I"
        let att_authority3: Vec<&str> = vec!["G","H","I"];
        let (_auth3_pk, _auth3_msk) = authgen(&_gp, &att_authority3).unwrap();

        // setup a user "bob" and give him some attribute-keys
        let att_bob: Vec<&str> = vec!["H","I"];
        let mut _bob = keygen(&_gp, &_auth3_msk, &String::from("bob"), &att_bob).unwrap();
        // our plaintext
        let _plaintext =
            String::from("dance like no one's watching, encrypt like everyone is!").into_bytes();
        // our policy
        let _policy = String::from(r#"{"name": "and", "children": [{"name": "H"}, {"name": "B"}]}"#);

        // add attribute "B" of auth1 to bobs key
        if let Err(e) = add_to_attribute(&_gp, &_auth1_msk, &String::from("B"), &mut _bob) {
            panic!("Error: {}", e.to_string())
        }
        // a vector of public attribute keys
        let pks: Vec<&Aw11PublicKey> = vec![&_auth3_pk, &_auth1_pk];
        // cp-abe ciphertext
        let ct_cp: Aw11Ciphertext = encrypt(&_gp, pks.as_slice(), &_policy, PolicyLanguage::JsonPolicy, &_plaintext).unwrap();
        // and now decrypt again with mathcing sk
        let _matching = decrypt(&_gp, &_bob, &ct_cp).unwrap();
        assert_eq!(_matching, _plaintext);
    }

    #[test]
    fn or() {
        // global setup
        let _gp = setup();
        // setup attribute authority 1 with
        // a set of two attributes "A" "B"
        let att_authority1: Vec<&str> = vec!["A","B"];
        let (_auth1_pk, _auth1_msk) = authgen(&_gp, &att_authority1).unwrap();
        // setup attribute authority 1 with
        // a set of two attributes "C" "D"
        let att_authority2: Vec<&str> = vec!["C","D"];
        let (_auth2_pk, _auth2_msk) = authgen(&_gp, &att_authority2).unwrap();

        // setup a user "bob" and give him some attribute-keys
        let mut _bob = keygen(
            &_gp,
            &_auth1_msk,
            &String::from("bob"),
            &vec!["A"],
        )
        .unwrap();

        // our plaintext
        let _plaintext =
            String::from("dance like no one's watching, encrypt like everyone is!").into_bytes();
        // our policy
        let _policy = String::from(r#"{"name": "or", "children": [{"name": "B"}, {"name": "C"}]}"#);

        // a vector of public attribute keys
        let pks: Vec<&Aw11PublicKey> = vec![&_auth2_pk, &_auth1_pk];
        // add attribute "C" of auth2 to bobs key
        if let Err(e) = add_to_attribute(&_gp, &_auth2_msk, &String::from("C"), &mut _bob) {
            panic!("Error: {}", e.to_string())
        }
        // cp-abe ciphertext
        let ct_cp: Aw11Ciphertext = encrypt(&_gp, &pks, &_policy,PolicyLanguage::JsonPolicy,  &_plaintext).unwrap();
        // and now decrypt again with mathcing sk
        let _matching = decrypt(&_gp, &_bob, &ct_cp).unwrap();
        assert_eq!(_matching, _plaintext);
    }

    #[test]
    fn or_and() {
        // global setup
        let _gp = setup();
        // setup attribute authority 1 with
        // a set of two attributes "A" "B"
        let att_authority1: Vec<&str> = vec!["A","B"];
        let (_auth1_pk, _auth1_msk) = authgen(&_gp, &att_authority1).unwrap();
        // setup attribute authority 1 with
        // a set of two attributes "C" "D"
        let att_authority2: Vec<&str> = vec!["C","D"];
        let (_auth2_pk, _auth2_msk) = authgen(&_gp, &att_authority2).unwrap();
        // setup a user "bob" and give him some attribute-keys
        let mut _bob = keygen(
            &_gp,
            &_auth1_msk,
            &String::from("bob"),
            &vec!["A"],
        )
        .unwrap();

        // our plaintext
        let _plaintext =
            String::from("dance like no one's watching, encrypt like everyone is!").into_bytes();
        // our policy
        let _policy =
            String::from(r#"{"name": "or", "children": [{"name": "B"}, {"name": "and", "children": [{"name": "C"}, {"name": "D"}]}]}"#);

        // a vector of public attribute keys
        let pks: Vec<&Aw11PublicKey> = vec![&_auth2_pk, &_auth1_pk];

        // add attribute "C" and "D" of auth2 to bobs key
        if let Err(e) = add_to_attribute(&_gp, &_auth2_msk, &String::from("C"), &mut _bob) {
            panic!("Error: {}", e.to_string())
        }
        if let Err(e) = add_to_attribute(&_gp, &_auth2_msk, &String::from("D"), &mut _bob) {
            panic!("Error: {}", e.to_string())
        }

        // cp-abe ciphertext
        let ct_cp: Aw11Ciphertext = encrypt(&_gp, pks.as_slice(), &_policy, PolicyLanguage::JsonPolicy, &_plaintext).unwrap();
        // and now decrypt again with mathcing sk
        let _matching = decrypt(&_gp, &_bob, &ct_cp).unwrap();
        assert_eq!(_matching, _plaintext);
    }

    #[test]
    fn not() {
        // global setup
        let _gp = setup();
        // setup attribute authority 1 with
        // a set of two attributes "A" "B"
        let att_authority1: Vec<&str> = vec!["A","B"];
        let (_auth1_pk, _auth1_msk) = authgen(&_gp, &att_authority1).unwrap();
        // setup attribute authority 1 with
        // a set of two attributes "C" "D"
        let att_authority2: Vec<&str> = vec!["C","D"];
        let (_auth2_pk, _auth2_msk) = authgen(&_gp, &att_authority2).unwrap();
        // setup a user "bob" and give him some attribute-keys
        let mut _bob = keygen(
            &_gp,
            &_auth1_msk,
            &String::from("bob"),
            &vec!["A"],
        )
        .unwrap();
        // our plaintext
        let _plaintext =
            String::from("dance like no one's watching, encrypt like everyone is!").into_bytes();
        // our policy
        let _policy =
            String::from(r#"{"name": "or", "children": [{"name": "B"}, {"name": "and", "children": [{"name": "C"}, {"name": "A"}]}]}"#);
        // a vector of public attribute keys
        let pks: Vec<&Aw11PublicKey> = vec![&_auth2_pk, &_auth1_pk];
        // add attribute "C" and "D" of auth2 to bobs key
        if let Err(e) = add_to_attribute(&_gp, &_auth2_msk, &String::from("D"), &mut _bob) {
            panic!("Error: {}", e.to_string())
        }
        // cp-abe ciphertext
        let ct_cp: Aw11Ciphertext = encrypt(&_gp, pks.as_slice(), &_policy, PolicyLanguage::JsonPolicy, &_plaintext).unwrap();
        // and now decrypt again
        let pt = decrypt(&_gp, &_bob, &ct_cp);
        assert_eq!(pt.is_ok(), false);
    }
}
