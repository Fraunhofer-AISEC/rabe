#pragma once

#include <cstddef>
#include <cstdint>
#include <stdexcept>
#include <string>
#include <vector>

// Forward-declare our context and use it as an opaque pointer. rabe will
// handle all memory management for us
struct CpAbeContext;
struct CpAbeSecretKey;
struct BufferFfi {
    uint8_t* data;
    size_t size;
};

// Function declarations for Rust functions
extern "C" {
    CpAbeContext* rabe_bsw_context_create();
    void rabe_bsw_context_destroy(CpAbeContext* ctx);

    CpAbeSecretKey* rabe_bsw_keygen(CpAbeContext* ctx, const char* attributes);
    void rabe_bsw_keygen_destroy(CpAbeSecretKey* secretKey);

    void rabe_bsw_free_buffer_ffi(BufferFfi* buffer);

    int32_t rabe_bsw_encrypt(
        CpAbeContext* ctx,
        const char* policy,
        const char* policyLanguage,
        const uint8_t* plainText,
        size_t plainTextLen,
        BufferFfi** cipherText);

    int32_t rabe_bsw_decrypt(
        CpAbeSecretKey* secretKey,
        // WARNING: cipherText must be null-terminated (consider treating it
        // as a string on C++, make sure we understand why Rabe uses it like
        // a string)
        const uint8_t* cipherText,
        BufferFfi** actualPlainText);
}

namespace tless::abe {
enum ContextFetchMode {
    Create,
    FromBytes,
    FromTmpFile,
    FromS3,
};

class CpAbeContextWrapper {
public:
    // Call the setup() procedure to generate a MasterKey and a PublicKey for
    // our CP-ABE scheme
    void createKeys();

    static CpAbeContextWrapper& get(
      const ContextFetchMode& fetchMode,
      const std::vector<uint8_t>& bytes = std::vector<uint8_t>())
    {
        static CpAbeContextWrapper ctx;

        if (fetchMode == ContextFetchMode::Create) {
            ctx.createKeys();
        } else if (fetchMode == ContextFetchMode::FromBytes) {
            if (bytes.empty()) {
                throw std::runtime_error("Must provide bytes in this fetch mode");
            }

            ctx.loadKeys(bytes);
        } else {
            ctx.fetchKeys(fetchMode);
        }

        return ctx;
    }

    // Load an external context from a byte array
    void loadKeys(const std::vector<uint8_t>& ctxBytes);

    // Serialize the context into an array. This is useful to then upload it
    // to S3 or something (maybe not on C++ tho, Rust probs better for the CLI)
    std::vector<uint8_t> dumpKeys();

    // Fetch the context generated by a trusted authority. This will use the
    // TLS channel established during remote-attestation
    bool fetchKeys(const ContextFetchMode& fetchMode);

    // Encrypt plain-text with an access-structure over the policy. The policy is
    // a string where sub-string values are and-ed or or-ed like:
    // std::string policy = "\"A\" and \"B\"";
    std::vector<uint8_t> cpAbeEncrypt(
        const std::string& policy,
        const std::vector<uint8_t>& plainText);

    std::vector<uint8_t> cpAbeEncrypt(
        const std::string& policy,
        const std::string& plainText);

    // Decryption will succeed if the attributes pass the policy with which the
    // cipher-text was encrypted. For example, if the policy is:
    // std::string policy = "\"A\" and \"B\"";
    // then, attributes must be
    // std::vector<std::string> attributes = { "A", "B" };
    std::vector<uint8_t> cpAbeDecrypt(
        const std::vector<std::string>& attributes,
        const std::vector<uint8_t>& cipherText);

    // TODO: move back to private
    CpAbeContext* _ctx = nullptr;
  private:
    std::string policyLanguage = "HumanPolicy";
    bool externalContext = false;

    ~CpAbeContextWrapper()
    {
        if (_ctx != nullptr) {
            if (externalContext) {
                free(_ctx);
            }
        } else {
            rabe_bsw_context_destroy(_ctx);
            _ctx = nullptr;
        }
    }
};
}
